use heck::ToUpperCamelCase;
use std::collections::BTreeMap;
use std::env;
use std::fs;
use std::path::Path;

/// Ensure identifier doesn't start with a number by prefixing with underscore or word
fn sanitize_identifier(name: &str) -> String {
    let camel = name.to_upper_camel_case();
    if camel.chars().next().is_some_and(|c| c.is_ascii_digit()) {
        format!("N{}", camel)
    } else {
        camel
    }
}

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let icons_dir = Path::new(&manifest_dir).join("assets/icons");

    println!("cargo:rerun-if-changed=assets/icons");

    // Collect all icons: category -> [(variant_name, file_name, asset_path)]
    let mut icons: BTreeMap<String, Vec<(String, String, String)>> = BTreeMap::new();

    if let Ok(categories) = fs::read_dir(&icons_dir) {
        for category_entry in categories.flatten() {
            let category_path = category_entry.path();
            if category_path.is_dir() {
                let category_dir_name = category_entry.file_name().to_string_lossy().to_string();
                let category_name = category_dir_name
                    .replace(" & ", " ")
                    .replace(' ', "_")
                    .to_upper_camel_case();

                if let Ok(files) = fs::read_dir(&category_path) {
                    for file_entry in files.flatten() {
                        let file_path = file_entry.path();
                        if file_path.extension().is_some_and(|ext| ext == "svg") {
                            let file_name =
                                file_path.file_stem().unwrap().to_string_lossy().to_string();

                            // Convert file name to enum variant name (sanitized)
                            let variant_name = sanitize_identifier(&file_name);
                            // Asset path for GPUI (relative to assets root)
                            let asset_path =
                                format!("icons/{}/{}.svg", category_dir_name, file_name);

                            icons.entry(category_name.clone()).or_default().push((
                                variant_name,
                                file_name,
                                asset_path,
                            ));
                        }
                    }
                }
            }
        }
    }

    // Sort icons within each category
    for entries in icons.values_mut() {
        entries.sort_by(|a, b| a.0.cmp(&b.0));
    }

    // Generate the icon_name module
    let mut code = String::new();
    code.push_str("// This file is auto-generated by build.rs. Do not edit manually.\n\n");

    // Generate category modules with their icons
    for (category, entries) in &icons {
        code.push_str(&format!("pub mod {} {{\n", category.to_lowercase()));
        code.push_str("    use super::*;\n\n");
        code.push_str("    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
        code.push_str("    pub enum Icon {\n");
        for (variant, _, _) in entries {
            code.push_str(&format!("        {},\n", variant));
        }
        code.push_str("    }\n\n");

        code.push_str("    impl crate::RemixIcon for Icon {\n");
        code.push_str("        fn path(self) -> SharedString {\n");
        code.push_str("            match self {\n");
        for (variant, _, asset_path) in entries {
            code.push_str(&format!(
                "                Self::{} => \"{}\".into(),\n",
                variant, asset_path
            ));
        }
        code.push_str("            }\n");
        code.push_str("        }\n");
        code.push_str("    }\n");
        code.push_str("}\n\n");
    }

    // Generate a flat enum with all icons (prefixed with category)
    code.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
    code.push_str("pub enum RemixIconName {\n");
    for (category, entries) in &icons {
        for (variant, _, _) in entries {
            code.push_str(&format!("    {}{},\n", category, variant));
        }
    }
    code.push_str("}\n\n");

    code.push_str("impl crate::RemixIcon for RemixIconName {\n");
    code.push_str("    fn path(self) -> SharedString {\n");
    code.push_str("        match self {\n");
    for (category, entries) in &icons {
        for (variant, _, asset_path) in entries {
            code.push_str(&format!(
                "            Self::{}{} => \"{}\".into(),\n",
                category, variant, asset_path
            ));
        }
    }
    code.push_str("        }\n");
    code.push_str("    }\n");
    code.push_str("}\n");

    // Write the generated code
    let dest_path = Path::new(&out_dir).join("icon_name.rs");
    fs::write(&dest_path, code).unwrap();
}
