use heck::ToUpperCamelCase;
use std::collections::BTreeMap;
use std::env;
use std::fs;
use std::path::Path;

/// Ensure identifier doesn't start with a number by prefixing with underscore or word
fn sanitize_identifier(name: &str) -> String {
    let camel = name.to_upper_camel_case();
    if camel.chars().next().is_some_and(|c| c.is_ascii_digit()) {
        format!("N{}", camel)
    } else {
        camel
    }
}

/// Convert category directory name to a valid Rust module/feature name (snake_case)
fn category_to_snake_case(name: &str) -> String {
    name.replace(" & ", "_and_")
        .replace(' ', "_")
        .to_lowercase()
}

/// Convert category directory name to CamelCase for struct names
fn category_to_camel_case(name: &str) -> String {
    name.replace(" & ", " ")
        .replace(' ', "_")
        .to_upper_camel_case()
}

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let icons_dir = Path::new(&manifest_dir).join("assets/icons");

    println!("cargo:rerun-if-changed=assets/icons");

    // Collect all icons: (category_dir_name, category_snake, category_camel) -> [(variant_name, file_name, asset_path)]
    let mut icons: BTreeMap<(String, String, String), Vec<(String, String, String)>> =
        BTreeMap::new();

    if let Ok(categories) = fs::read_dir(&icons_dir) {
        for category_entry in categories.flatten() {
            let category_path = category_entry.path();
            if category_path.is_dir() {
                let category_dir_name = category_entry.file_name().to_string_lossy().to_string();
                let category_snake = category_to_snake_case(&category_dir_name);
                let category_camel = category_to_camel_case(&category_dir_name);

                if let Ok(files) = fs::read_dir(&category_path) {
                    for file_entry in files.flatten() {
                        let file_path = file_entry.path();
                        if file_path.extension().is_some_and(|ext| ext == "svg") {
                            let file_name =
                                file_path.file_stem().unwrap().to_string_lossy().to_string();

                            // Convert file name to enum variant name (sanitized)
                            let variant_name = sanitize_identifier(&file_name);
                            // Asset path for GPUI (relative to assets root)
                            let asset_path =
                                format!("icons/{}/{}.svg", category_dir_name, file_name);

                            icons
                                .entry((
                                    category_dir_name.clone(),
                                    category_snake.clone(),
                                    category_camel.clone(),
                                ))
                                .or_default()
                                .push((variant_name, file_name, asset_path));
                        }
                    }
                }
            }
        }
    }

    // Sort icons within each category
    for entries in icons.values_mut() {
        entries.sort_by(|a, b| a.0.cmp(&b.0));
    }

    // Generate the icon_name module
    let mut code = String::new();
    code.push_str("// This file is auto-generated by build.rs. Do not edit manually.\n\n");

    // Generate category modules with their icons
    for ((_, category_snake, category_camel), entries) in &icons {
        code.push_str(&format!("#[cfg(feature = \"{}\")]\n", category_snake));
        code.push_str(&format!("pub mod {} {{\n", category_snake));
        code.push_str("    use super::*;\n\n");
        code.push_str("    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
        code.push_str("    pub enum Icon {\n");
        for (variant, _, _) in entries {
            code.push_str(&format!("        {},\n", variant));
        }
        code.push_str("    }\n\n");

        code.push_str("    impl crate::RemixIcon for Icon {\n");
        code.push_str("        fn path(self) -> SharedString {\n");
        code.push_str("            match self {\n");
        for (variant, _, asset_path) in entries {
            code.push_str(&format!(
                "                Self::{} => \"{}\".into(),\n",
                variant, asset_path
            ));
        }
        code.push_str("            }\n");
        code.push_str("        }\n");
        code.push_str("    }\n\n");

        // Generate Assets struct for this category
        code.push_str(&format!(
            "    /// Assets for {} icons. Implements `AssetSource` for GPUI.\n",
            category_camel
        ));
        code.push_str(&format!("    #[derive(rust_embed::RustEmbed)]\n"));
        code.push_str(&format!("    #[folder = \"assets\"]\n"));
        code.push_str(&format!(
            "    #[include = \"icons/{}/*.svg\"]\n",
            category_camel
                .replace("And", " & ")
                .replace("Faces", " Faces")
                .replace("Medical", " Medical")
        ));
        code.push_str(&format!("    pub struct {}Assets;\n\n", category_camel));

        code.push_str(&format!(
            "    impl gpui::AssetSource for {}Assets {{\n",
            category_camel
        ));
        code.push_str("        fn load(&self, path: &str) -> gpui::Result<Option<std::borrow::Cow<'static, [u8]>>> {\n");
        code.push_str("            if path.is_empty() {\n");
        code.push_str("                return Ok(None);\n");
        code.push_str("            }\n");
        code.push_str("            Self::get(path)\n");
        code.push_str("                .map(|f| Some(f.data))\n");
        code.push_str("                .ok_or_else(|| anyhow::anyhow!(\"could not find asset at path \\\"{path}\\\"\"))\n");
        code.push_str("        }\n\n");
        code.push_str("        fn list(&self, path: &str) -> gpui::Result<Vec<SharedString>> {\n");
        code.push_str("            Ok(Self::iter()\n");
        code.push_str("                .filter_map(|p| p.starts_with(path).then(|| p.into()))\n");
        code.push_str("                .collect())\n");
        code.push_str("        }\n");
        code.push_str("    }\n");
        code.push_str("}\n\n");
    }

    // Generate a flat enum with all icons (prefixed with category)
    code.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
    code.push_str("pub enum RemixIconName {\n");
    for ((_, category_snake, category_camel), entries) in &icons {
        code.push_str(&format!("    #[cfg(feature = \"{}\")]\n", category_snake));
        for (variant, _, _) in entries {
            code.push_str(&format!("    {}{},\n", category_camel, variant));
        }
    }
    code.push_str("}\n\n");

    code.push_str("impl crate::RemixIcon for RemixIconName {\n");
    code.push_str("    fn path(self) -> SharedString {\n");
    code.push_str("        match self {\n");
    for ((_, category_snake, category_camel), entries) in &icons {
        code.push_str(&format!(
            "            #[cfg(feature = \"{}\")]\n",
            category_snake
        ));
        for (variant, _, asset_path) in entries {
            code.push_str(&format!(
                "            Self::{}{} => \"{}\".into(),\n",
                category_camel, variant, asset_path
            ));
        }
    }
    code.push_str("        }\n");
    code.push_str("    }\n");
    code.push_str("}\n");

    // Generate the assets module
    let mut assets_code = String::new();
    assets_code.push_str("// This file is auto-generated by build.rs. Do not edit manually.\n\n");
    assets_code.push_str("use std::borrow::Cow;\n\n");

    // Generate combined Assets struct
    assets_code.push_str("/// Combined Assets for all enabled icon categories.\n");
    assets_code.push_str("/// Implements `AssetSource` for GPUI.\n");
    assets_code.push_str("///\n");
    assets_code.push_str("/// ```\n");
    assets_code.push_str("/// use gpui::*;\n");
    assets_code.push_str("/// use gpui_remixicon::Assets;\n");
    assets_code.push_str("///\n");
    assets_code.push_str("/// let app = Application::new().with_assets(Assets);\n");
    assets_code.push_str("/// ```\n");
    assets_code.push_str("#[derive(rust_embed::RustEmbed)]\n");
    assets_code.push_str("#[folder = \"assets\"]\n");

    // Add include patterns for all categories based on features
    for ((category_dir_name, category_snake, _), _) in &icons {
        assets_code.push_str(&format!(
            "#[cfg_attr(feature = \"{}\", include = \"icons/{}/*.svg\")]\n",
            category_snake, category_dir_name
        ));
    }
    assets_code.push_str("pub struct Assets;\n\n");

    assets_code.push_str("impl gpui::AssetSource for Assets {\n");
    assets_code
        .push_str("    fn load(&self, path: &str) -> gpui::Result<Option<Cow<'static, [u8]>>> {\n");
    assets_code.push_str("        if path.is_empty() {\n");
    assets_code.push_str("            return Ok(None);\n");
    assets_code.push_str("        }\n");
    assets_code.push_str("        Self::get(path)\n");
    assets_code.push_str("            .map(|f| Some(f.data))\n");
    assets_code.push_str("            .ok_or_else(|| anyhow::anyhow!(\"could not find asset at path \\\"{path}\\\"\"))\n");
    assets_code.push_str("    }\n\n");
    assets_code.push_str("    fn list(&self, path: &str) -> gpui::Result<Vec<SharedString>> {\n");
    assets_code.push_str("        Ok(Self::iter()\n");
    assets_code.push_str("            .filter_map(|p| p.starts_with(path).then(|| p.into()))\n");
    assets_code.push_str("            .collect())\n");
    assets_code.push_str("    }\n");
    assets_code.push_str("}\n");

    // Write the generated code
    let dest_path = Path::new(&out_dir).join("icon_name.rs");
    fs::write(&dest_path, code).unwrap();

    let assets_path = Path::new(&out_dir).join("assets.rs");
    fs::write(&assets_path, assets_code).unwrap();
}
